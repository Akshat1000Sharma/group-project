<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Othello Game</title>
    <script src="https://cdn.jsdelivr.net/npm/brython@3.12.4/brython.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            text-align: center;
        }
        #output {
            font-family: 'Courier New', monospace;
            white-space: pre;
            border: 1px solid #ccc;
            padding: 10px;
            height: 500px;
            overflow-y: auto;
            background-color: #000;
            color: #fff;
            margin-bottom: 10px;
        }
        .instructions {
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body onload="brython()">
    <h1>Othello Game</h1>
    <div class="instructions">
        <p>The game runs in the terminal box below. Human plays black (starts first). When prompted, a dialog will appear for input (e.g., "2 3"). The board uses B for black, W for white, . for empty. AI plays white.</p>
    </div>
    <div id="output"></div>

    <script type="text/python">
# Redirect print to the output div
from browser import document

def custom_print(*args, **kwargs):
    sep = kwargs.get('sep', ' ')
    end = kwargs.get('end', '\n')
    text = sep.join(map(str, args)) + end
    output_div = document['output']
    # Replace newlines with <br> for HTML rendering
    html_text = text.replace('\n', '<br>\n')
    output_div.innerHTML += html_text
    # Scroll to bottom
    output_div.scrollTop = output_div.scrollHeight

# Monkey-patch the built-in print function
import __builtins__
__builtins__['print'] = custom_print

# Original Python code (unchanged)
import copy
# Board representation: 8x8 grid, 0=empty, 1=black (human), -1=white (AI)
BOARD_SIZE = 8
INITIAL_BOARD = [
    [0] * BOARD_SIZE for _ in range(BOARD_SIZE)
]
# Corrected starting position: Diagonals
INITIAL_BOARD[3][3] = -1 # White
INITIAL_BOARD[3][4] = 1 # Black
INITIAL_BOARD[4][3] = 1 # Black
INITIAL_BOARD[4][4] = -1 # White
class Othello:
    def __init__(self):
        self.board = copy.deepcopy(INITIAL_BOARD)
        self.current_player = 1 # Human starts (black)
        self.game_over = False
    
    def display_board(self):
        print(" ", end="")
        for col in range(BOARD_SIZE):
            print(f" {col} ", end="")
        print()
        for row in range(BOARD_SIZE):
            print(f"{row} ", end="")
            for cell in self.board[row]:
                if cell == 1:
                    print(" B ", end="")
                elif cell == -1:
                    print(" W ", end="")
                else:
                    print(" . ", end="")
            print()
        print()
    
    def get_valid_moves(self, player):
        """Find all valid moves for the player."""
        moves = []
        directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]
        for r in range(BOARD_SIZE):
            for c in range(BOARD_SIZE):
                if self.board[r][c] == 0: # Empty cell
                    for dr, dc in directions:
                        if self._is_valid_flip(r, c, dr, dc, player):
                            moves.append((r, c))
                            break # Valid if at least one direction flips
        return list(set(moves)) # Remove duplicates
    
    def _is_valid_flip(self, r, c, dr, dc, player):
        """Check if placing at (r,c) flips in direction (dr,dc)."""
        r += dr
        c += dc
        if not (0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE) or self.board[r][c] != -player:
            return False
        while 0 <= r < BOARD_SIZE and 0 <= c < BOARD_SIZE:
            if self.board[r][c] == player:
                return True
            if self.board[r][c] == 0:
                return False
            r += dr
            c += dc
        return False
    
    def make_move(self, r, c, player):
        """Place piece and flip opponents."""
        if (r, c) not in self.get_valid_moves(player):
            return False
        directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]
        self.board[r][c] = player
        for dr, dc in directions:
            if self._is_valid_flip(r, c, dr, dc, player):
                nr, nc = r + dr, c + dc
                while self.board[nr][nc] == -player:
                    self.board[nr][nc] = player
                    nr += dr
                    nc += dc
        self.current_player = -player
        return True
    
    def evaluate_board(self, player):
        """Heuristic: Pieces + Mobility (valid moves)."""
        score = 0
        # Piece count
        black_pieces = sum(1 for row in self.board for cell in row if cell == 1)
        white_pieces = sum(1 for row in self.board for cell in row if cell == -1)
        score += (black_pieces - white_pieces) * (1 if player == 1 else -1)
        
        # Mobility
        black_moves = len(self.get_valid_moves(1))
        white_moves = len(self.get_valid_moves(-1))
        score += (black_moves - white_moves) * (2 if player == 1 else -2)
        
        return score
    
    def is_terminal(self):
        """Check if game over (no moves for both players)."""
        return len(self.get_valid_moves(self.current_player)) == 0 and \
               len(self.get_valid_moves(-self.current_player)) == 0
    
    def get_winner(self):
        """Return winner: 1 black, -1 white, 0 draw."""
        black = sum(1 for row in self.board for cell in row if cell == 1)
        white = sum(1 for row in self.board for cell in row if cell == -1)
        if black > white:
            return 1
        elif white > black:
            return -1
        return 0
def minimax(game, depth, alpha, beta, maximizing_player):
    """Minimax with Alpha-Beta Pruning."""
    if depth == 0 or game.is_terminal():
        return game.evaluate_board(1) # Evaluate from black's perspective
    
    moves = game.get_valid_moves(game.current_player)
    if not moves:
        game.current_player = -game.current_player # Skip turn
        val = minimax(game, depth, alpha, beta, maximizing_player)
        game.current_player = -game.current_player # Revert
        return val
    
    if maximizing_player:
        max_eval = float('-inf')
        for r, c in moves:
            new_game = copy.deepcopy(game)
            new_game.make_move(r, c, game.current_player)
            eval_score = minimax(new_game, depth - 1, alpha, beta, False)
            max_eval = max(max_eval, eval_score)
            alpha = max(alpha, eval_score)
            if beta <= alpha:
                break
        return max_eval
    else:
        min_eval = float('inf')
        for r, c in moves:
            new_game = copy.deepcopy(game)
            new_game.make_move(r, c, game.current_player)
            eval_score = minimax(new_game, depth - 1, alpha, beta, True)
            min_eval = min(min_eval, eval_score)
            beta = min(beta, eval_score)
            if beta <= alpha:
                break
        return min_eval
def ai_move(game, depth=4):
    """AI selects best move using Minimax."""
    best_score = float('-inf')
    best_move = None
    moves = game.get_valid_moves(game.current_player)
    for r, c in moves:
        new_game = copy.deepcopy(game)
        new_game.make_move(r, c, game.current_player)
        score = minimax(new_game, depth - 1, float('-inf'), float('inf'), False)
        if score > best_score:
            best_score = score
            best_move = (r, c)
    if best_move:
        game.make_move(best_move[0], best_move[1], game.current_player)
    return best_move
# Game Loop
def play_game():
    game = Othello()
    while not game.is_terminal():
        game.display_board()
        if game.current_player == 1: # Human
            print("Your turn (black). Enter row,col (e.g., 2 3): ")
            try:
                r, c = map(int, input().split())
                if not game.make_move(r, c, 1):
                    print("Invalid move! Try again.")
                    continue
            except:
                print("Invalid input!")
                continue
        else: # AI
            print("AI thinking...")
            move = ai_move(game)
            print(f"AI moves to {move}")
        
        # Check if opponent has moves; if not, skip
        if len(game.get_valid_moves(game.current_player)) == 0:
            print(f"No moves for { 'AI' if game.current_player == -1 else 'Human' }. Skipping turn.")
            game.current_player = -game.current_player
    
    game.display_board()
    winner = game.get_winner()
    if winner == 1:
        print("Human (Black) wins!")
    elif winner == -1:
        print("AI (White) wins!")
    else:
        print("Draw!")
if __name__ == "__main__":
    play_game()
    </script>
</body>
</html>